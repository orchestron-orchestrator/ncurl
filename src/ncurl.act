#!/usr/bin/env acton
"""ncurl - NETCONF URL tool

A command-line tool for interacting with NETCONF devices, like curl but for
NETCONF. Maybe one day we'll do RESTCONF and gNMI (the other YANG-based
transports), and then we'll be network curl.
"""

import argparse
import file
import logging
import netconf
import time
import xml


import yang
import yang.gen3




actor CmdListSchemas(env, args, log_handler):
    """List available schemas from a NETCONF server"""

    host = args.get_str("host")
    port = args.get_int("port")
    username = args.get_str("username")
    password = args.get_str("password")
    skip_host_key_check = args.get_bool("insecure")

    var schemas_found = []

    def _on_connect(c: netconf.Client, e: ?Exception):
        if e is not None:
            print("Error: Failed to connect: {e}", err=True)
            env.exit(1)
        else:
            c.list_schemas(_on_list_schemas)

    def _on_list_schemas(c: netconf.Client, schemas: list[(identifier: ?str, namespace: ?str, version: ?str, format: ?str)], error: ?netconf.NetconfError):
        for schema in schemas:
            schemas_found.append(schema)

        def _close_cb():
            _display_schemas()

        c.close(_close_cb)

    def _display_schemas():
        print("Available schemas:")
        print("==================")
        count = 0
        for schema in schemas_found:
            version_str = str(schema.version) if schema.version is not None else "N/A"
            format_str = str(schema.format) if schema.format is not None else "N/A"
            identifier_str = str(schema.identifier) if schema.identifier is not None else "N/A"
            namespace_str = str(schema.namespace) if schema.namespace is not None else "N/A"
            print("  {identifier_str:<40} {version_str:<15} {format_str:<5} {namespace_str}")
            count += 1

        print("\nTotal schemas: {count}")
        env.exit(0)

    c = netconf.Client(env.auth,
                      on_connect=_on_connect,
                      on_notif=None,
                      address=host,
                      username=username,
                      key=None,
                      password=password,
                      port=port,
                      skip_host_key_check=skip_host_key_check,
                      log_handler=log_handler)


actor CmdGetConfig(env, args, log_handler):
    """Get configuration from a NETCONF server"""

    host = args.get_str("host")
    port = args.get_int("port")
    username = args.get_str("username")
    password = args.get_str("password")
    skip_host_key_check = args.get_bool("insecure")
    source = args.get_str("source")
    filter_subtree = args.get_str("filter-subtree")
    filter_xpath = args.get_str("filter-xpath")
    xpath_namespaces = args.get_strlist("xpath-namespaces")
    output_file = args.get_str("output")
    format = args.get_str("format")

    var config_xml: ?xml.Node = None
    var client: ?netconf.Client = None
    var schemas: list[str] = []

    def _on_connect(c: netconf.Client, e: ?Exception):
        if e is not None:
            print("Error: Failed to connect: {e}", err=True)
            env.exit(1)

        # Build filter if provided
        filter_node: ?xml.Node = None

        if filter_subtree != "" and filter_xpath != "":
            print("Error: Cannot specify both filter-subtree and filter-xpath", err=True)
            env.exit(1)

        if filter_subtree != "":
            # Wrap subtree filter in <filter> element
            try:
                subtree_node = xml.decode(filter_subtree)
                filter_node = xml.Node("filter", attributes=[("type", "subtree")], children=[subtree_node], text=None)
            except xml.XmlParseError as parse_error:
                print("Error: Invalid subtree filter XML: {parse_error.error_message}", err=True)
                env.exit(1)
        elif filter_xpath != "":
            # Create XPath filter with proper namespace
            filter_attrs = [("type", "xpath"), ("select", filter_xpath)]

            # Add namespace declarations if provided
            # Each namespace should be in format "prefix=uri"
            nsdefs = []
            for ns_decl in xpath_namespaces:
                parts = ns_decl.split("=")
                if len(parts) == 2:
                    prefix = parts[0].strip()
                    uri = parts[1].strip()
                    nsdefs.append((prefix, uri))
                else:
                    print("Error: Invalid namespace format '{ns_decl}'. Use prefix=uri", err=True)
                    env.exit(1)

            filter_node = xml.Node("filter", nsdefs, attributes=filter_attrs)

        c.get_config(_on_get_config, source, filter_node)

    def _on_get_config(c: netconf.Client, result: ?xml.Node, error: ?netconf.NetconfError):
        # Check for errors
        if error is not None:
            print("Error getting config: {error.error_message}", err=True)
            env.exit(1)

        # Extract data element
        if result is not None:
            for child in result.children:
                if child.tag == "data":
                    config_xml = child
                    break

        if config_xml is None:
            print("No data element in response", err=True)
            env.exit(1)

        # If format is not raw-xml, fetch schemas
        if format != "raw-xml":
            print("Fetching schemas for data conversion...")
            schema_getter = SchemaGetter(c, log_handler)
            schema_getter.download(_on_schema_download, _on_schemas_complete, "all")
        else:
            # For raw-xml, just output the config
            if config_xml is not None:
                # Extract just the configuration data content
                config = ""
                if len(config_xml.children) > 0:
                    # Encode children of data element
                    for data_child in config_xml.children:
                        config += data_child.encode()
                elif config_xml.text is not None:
                    # If data element has text content
                    config = str(config_xml.text)
                _output_config(config)

    def _on_schema_download(current_index: int, total_schemas: int, schema: (identifier: ?str, namespace: ?str, version: ?str, format: ?str), schema_data: ?str):
        """Collect downloaded schemas into the list"""
        if schema_data is not None:
            schema_identifier = schema.identifier
            # Skip models:
            # - junos-rpc: all RPC modules use an undefined grouping?!
            # - openconfig: on Cisco IOS XRd openconfig-mpls.yang doesn't compile because submodule overrides prefix of parent import
            if schema_identifier is not None and (schema_identifier.startswith("junos-rpc") or "openconfig" in schema_identifier):
                print("Skipping {schema_identifier}", err=True)
                return
            schemas.append(schema_data)

    def _on_schemas_complete(error: ?netconf.NetconfError):
        """Called when all schemas have been downloaded"""
        if error is not None:
            print("Error fetching schemas: {error.error_message}", err=True)
            def _close_cb():
                env.exit(1)
            if client is not None:
                client.close(_close_cb)
            else:
                env.exit(1)
            return
        def _close_cb():
            env.exit(1)

        print("Retrieved {len(schemas)} schemas")

        t0 = time.Stopwatch()
        root = yang.compile(schemas)
        print("Compiled schemas in {t0.elapsed().to_float()}s")
        t0.reset()
        c = config_xml
        if c is not None:
            gdata = yang.gen3.from_xml(root, c, loose=True)
            print("Parsed config to gdata in {t0.elapsed().to_float()}s")

            if format == "json":
                _output_config(gdata.to_json())
                return
            elif format == "acton-gdata":
                _output_config(gdata.prsrc())
                return
            elif format == "acton-adata":
                _output_config(yang.gen3.pradata(root, gdata, loose=True))
                return
            elif format == "xml":
                _output_config(gdata.to_xmlstr())
                return

            print("Unknown output format")
            if client is not None:
                client.close(_close_cb)
            else:
                env.exit(1)
        else:
            print("No config")
            if client is not None:
                client.close(_close_cb)
            else:
                env.exit(1)

    def _output_config(config):
        """Output the configuration data"""
        if output_file != "":
            # Write to file
            f = file.WriteFile(file.WriteFileCap(file.FileCap(env.auth)), output_file)
            f.write(config.encode())
            f.close()
            print("Configuration saved to: {output_file}")
        else:
            # Print to stdout
            print(config)

        def _close_cb():
            env.exit(0)

        if client is not None:
            client.close(_close_cb)
        else:
            env.exit(0)

    client = netconf.Client(env.auth,
                      on_connect=_on_connect,
                      on_notif=None,
                      address=host,
                      username=username,
                      key=None,
                      password=password,
                      port=port,
                      skip_host_key_check=skip_host_key_check,
                      log_handler=log_handler)

actor SchemaGetter(client, log_handler):
    """Helper actor for downloading schemas from NETCONF server."""

    var schemas_to_download: list[(identifier: ?str, namespace: ?str, version: ?str, format: ?str)] = []
    var current_download_index = 0
    var on_get_schema_cb: ?action(int, int, (identifier: ?str, namespace: ?str, version: ?str, format: ?str), ?str) -> None = None
    var on_done_cb: ?action(?netconf.NetconfError) -> None = None

    def download(on_get_schema: action(int, int, (identifier: ?str, namespace: ?str, version: ?str, format: ?str), ?str) -> None, on_done: action(?netconf.NetconfError) -> None, identifier_str: str):
        """Download schemas. If identifier_str is 'all', download all schemas."""
        on_get_schema_cb = on_get_schema
        on_done_cb = on_done
        schemas_to_download = []
        current_download_index = 0

        if identifier_str == "all":
            # Get list of all schemas first
            client.list_schemas(_on_list_schemas)
        else:
            # Download single schema
            schemas_to_download.append((identifier=identifier_str, namespace=None, version=None, format="yang"))
            _download_next_schema()

    def _on_list_schemas(c: netconf.Client, schemas: list[(identifier: ?str, namespace: ?str, version: ?str, format: ?str)], error: ?netconf.NetconfError):
        """Handle schema list response"""
        if error is not None:
            # Pass error to completion callback
            if on_done_cb is not None:
                on_done_cb(error)
            return

        # Only download yang format (not yin) to avoid duplicates
        for schema in schemas:
            if schema.identifier is not None and schema.format == "yang":
                schemas_to_download.append(schema)

        _download_next_schema()

    def _download_next_schema():
        """Download the next schema in the queue"""
        if current_download_index >= len(schemas_to_download):
            # All schemas downloaded successfully
            if on_done_cb is not None:
                on_done_cb(None)
        else:
            schema = schemas_to_download[current_download_index]

            schema_identifier = schema.identifier
            if schema_identifier is None:
                # Skip schema with no identifier
                current_download_index += 1
                _download_next_schema()
                return

            ident = schema_identifier if schema_identifier is not None else ""

            # Use "yang" as default format if not specified
            format_str = schema.format if schema.format is not None else "yang"
            client.get_schema(_on_get_schema, ident, schema.version, format_str)

    def _on_get_schema(c: netconf.Client, result: ?xml.Node, error: ?netconf.NetconfError):
        """Handle individual schema response"""
        if current_download_index < len(schemas_to_download):
            schema = schemas_to_download[current_download_index]

            schema_data: ?str = None

            if error is None:
                # Extract schema data
                if result is not None:
                    for child in result.children:
                        if child.tag == "data":
                            schema_data = child.text
                            break

            # Call the callback with current progress and schema data
            if on_get_schema_cb is not None:
                on_get_schema_cb(current_download_index, len(schemas_to_download), schema, schema_data)

        # Move to next schema
        current_download_index += 1
        _download_next_schema()

actor CmdGetSchema(env, args, log_handler):
    """Download schema(s) from a NETCONF server"""

    host = args.get_str("host")
    port = args.get_int("port")
    username = args.get_str("username")
    password = args.get_str("password")
    skip_host_key_check = args.get_bool("insecure")
    identifier_str = args.get_str("identifier")
    version_str = args.get_str("version")
    version = version_str if version_str != "" else None
    format = args.get_str("format")
    output_dir = args.get_str("output-dir")

    var client: ?netconf.Client = None
    var schema_getter: ?SchemaGetter = None

    def _on_connect(c: netconf.Client, e: ?Exception):
        if e is not None:
            print("Error: Failed to connect: {e}", err=True)
            env.exit(1)
        else:
            schema_getter = SchemaGetter(c, log_handler)

            # Start download using SchemaGetter
            sg = schema_getter
            if sg is not None:
                sg.download(_on_schema_download, _on_download_complete, identifier_str)

    def _on_schema_download(current_index: int, total_schemas: int, schema: (identifier: ?str, namespace: ?str, version: ?str, format: ?str), schema_data: ?str):
        """Handle each downloaded schema"""
        print("Downloading [{current_index + 1}/{total_schemas}]: {schema.identifier}")

        if schema_data is not None:
            # Build proper filename with identifier and version
            filename = "{schema.identifier}"
            if schema.version is not None:
                filename = "{schema.identifier}@{schema.version}"
            if schema.format is not None:
                filename = "{filename}.{schema.format}"
            else:
                filename = "{filename}.yang"

            if output_dir not in {"", "."}:
                fs = file.FS(file.FileCap(env.auth))
                try:
                    await async fs.mkdir(output_dir)
                except OSError as err:
                    if "already exists" not in err.error_message:
                        raise err
                filepath = file.join_path([output_dir, filename])
            else:
                filepath = filename

            # Write to file
            f = file.WriteFile(file.WriteFileCap(file.FileCap(env.auth)), filepath)
            f.write(schema_data.encode())
            f.close()
            print("  Saved to: {filepath}")
        else:
            print("  Warning: No data received for {schema.identifier}")

    def _on_download_complete(error: ?netconf.NetconfError):
        """Called when all schemas have been downloaded"""
        if error is not None:
            print("\nError downloading schemas: {error.error_message}", err=True)
            env.exit(1)
            return

        print("\nAll schemas downloaded successfully!")
        _close_and_exit()

    def _close_and_exit():
        if client is not None:
            def _close_cb():
                env.exit(0)
            client.close(_close_cb)
        else:
            env.exit(0)

    # Connect and start the download process
    client = netconf.Client(env.auth,
                  on_connect=_on_connect,
                  on_notif=None,
                  address=host,
                  username=username,
                  key=None,
                  password=password,
                  port=port,
                  skip_host_key_check=skip_host_key_check,
                  log_handler=log_handler)


actor main(env):
    logh = logging.Handler()

    def cmd_list_schemas(args):
        """Command handler for list-schemas"""
        if args.get_bool("verbose"):
            logh.set_output_level(logging.TRACE)
            logh.add_sink(logging.ConsoleSink())
        CmdListSchemas(env, args, logh)

    def cmd_get_config(args):
        """Command handler for get-config"""
        if args.get_bool("verbose"):
            logh.set_output_level(logging.TRACE)
            logh.add_sink(logging.ConsoleSink())
        CmdGetConfig(env, args, logh)

    def cmd_get_schema(args):
        """Command handler for get-schema"""
        if args.get_bool("verbose"):
            logh.set_output_level(logging.TRACE)
            logh.add_sink(logging.ConsoleSink())
        CmdGetSchema(env, args, logh)

    def _parse_args():
        p = argparse.Parser()

        # Global options
        p.add_option("host", "str", "?", "localhost", "NETCONF server hostname")
        p.add_option("port", "int", "?", 42830, "NETCONF server port")
        p.add_option("username", "str", "?", "admin", "Username for authentication")
        p.add_option("password", "str", "?", "admin", "Password for authentication")
        p.add_bool("verbose", "Verbose logging from SSH / NETCONF client")
        p.add_bool("insecure", "Disable SSH host key verification")

        # Commands
        p_list_schemas = p.add_cmd("list-schemas", "List available schemas", cmd_list_schemas)

        p_get_config = p.add_cmd("get-config", "Get configuration from NETCONF server", cmd_get_config)
        p_get_config.add_option("source", "str", "?", "running", "Configuration datastore (running, startup, candidate)")
        p_get_config.add_option("filter-subtree", "str", "?", "", "XML subtree filter")
        p_get_config.add_option("filter-xpath", "str", "?", "", "XPath expression for filtering")
        p_get_config.add_option("xpath-namespaces", "strlist", "*", [], "Namespace declarations for XPath filtering (format: prefix=uri)")
        p_get_config.add_option("format", "str", "?", "raw-xml", "Output format (raw-xml, xml, json, acton-gdata or acton-adata")
        p_get_config.add_option("output", "str", "?", "", "Output file (if not specified, prints to stdout)")

        p_get_schema = p.add_cmd("get-schema", "Download schema(s) from NETCONF server", cmd_get_schema)
        p_get_schema.add_arg("identifier", "Schema identifier or 'all' to download all schemas", True, "?")
        p_get_schema.add_option("version", "str", "?", "", "Schema version")
        p_get_schema.add_option("format", "str", "?", "yang", "Schema format (yang or yin)")
        p_get_schema.add_option("output-dir", "str", "?", "schemas", "Output directory for downloaded schemas")

        return p.parse(env.argv)

    try:
        args = _parse_args()
        cmd = args.cmd
        if cmd is not None:
            cmd(args)
        else:
            env.exit(0)
    except argparse.ArgumentError as exc:
        print(str(exc), err=True)
        env.exit(1)
